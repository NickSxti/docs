---
title: "Migrating from RevenueCat"
description: "We have prepared this guide to help you move your infrastructure seamlessly from RevenueCat to Qonversion. Although this guide is comprehensive and should enable you to transfer the entire infrastructure smoothly, feel free to reach out to support if you have any questions."
---

1. [Configure dashboard](#configure-dashboard)
2. [Install SDKs](#install-sdks)
3. [User-base migration](#user-base-migration)

# Configure dashboard

First and foremost, [register](https://go.qonversion.io/Ouf6) at Qonversion. Registration will take you through an onboarding process, where you'll have to fill out information about your project and insert links — all to help you add your project to Qonversion. We highly recommend following this flow and not skipping any settings during registration. We'll also cover the scenario if you don't fill these out.

## Store Settings

First, let's set up your Stores in the Qonversion dashboard. To do this, gather the necessary data from RevenueCat.

### Apple App Store settings

To configure the Apple App Store in Qonversion, you will need the following fields:

1. **App-Specific Shared Secret**: Copy this value from the App Store Connect App-specific Shared Secret field in the App Settings app settings in the RevenueCat dashboard. See the screen below. [Here's](app-specific-shared-secret) a more detailed guide on how to obtain this.
2. **App Store ID**: You'll find your App Store ID in the URL of your App Store Connect account. For example, if your URL is something like `https://apps.apple.com/us/app/example-app/id123456789`, then 123456789 is your app’s Apple ID.

![](/images/docs/fc335e7c262a841520770c755d61b84bb78edb4e0a0125d58c0457190b968855-288730196-7ddfb6e9-d730-4440-baba-d94bef820288.png)

### Google Play Console Settings

Here's what you have in RevenueCat:

![](/images/docs/dc7af47631a54426d1233cf30811d91e82c0c4020a95578db79328770783dba3-c0354f7-Crede_Step4_07775174e9aea4a27b191d018f8c467d-5754fba216819eee219f7a0007d14a31.gif)

To set up your Google Play account in Qonversion, you will need the following:

1. **Android Package Name**: This is the applicationID found in your app-level build.gradle file. You can either copy it from there or use the **Google play package** from your RevenueCat settings.
2. **Service Account Credentials JSON**: attach the same file you used for **Service Account Credentials JSON** at RevenueCat. [Here's more](service-account-key-android) on how you can get Google Play Service Account Key.

<Check>
  ### Configure Stores in Qonversion

  Once you have all the necessary data from RevenueCat, follow the steps to set up Stores in Qonversion
</Check>

[Stores Settings](https://demo.arcade.software/Eq6Y1v6okCVCUhOcYfUF?embed\&embed_mobile=inline\&embed_desktop=inline\&show_copy_link=true)

## Products, Entitlements and Remote Configs

After you've filled the store data, it's time to set up Offerings, Products, and Entitlements. Here's another way to describe these elements:

| RevenueCat   | Qonversion   |
| ------------ | ------------ |
| Entitlements | Entitlements |
| Packages     | Products     |
| Offerings    | Offerings    |

### Entitlements

Let's start with Entitlements. Similar to how you set up Entitlements in RevenueCat, you need to set up Entitlements in Qonversion.

Here’s how it was done in RevenueCat:

![](/images/docs/dfcd8b55223f7b512c43f7c68b985d5e9ee39bd5f2f473e116f640ee2f98b1b7-d09bed8-app.revenuecat.com_projects_3310b6dd_entitlements_fac76e7e636bfc467b3b956483e8d89c-7869f0ddd926c5525e19eb09d8d7dc00.png)

Here’s how to do it in Qonversion:

Navigate to the Entitlements and click the **Create Entitlement** button.

[Create entitlements](https://demo.arcade.software/dYOIEanZRhOmQ9zidazH?embed\&embed_mobile=inline\&embed_desktop=inline\&show_copy_link=true)

### Products

Next, you need to create Products similar to how you created in RevenueCat:

![](/images/docs/d9d53e1c72027c15df45ed3dea2745c533b14895cd691e9e72323d0e30066909-47e4904-Screenshot_2023-03-20_at_16.04.55_2bf3bf6fb0d0340d8c4cd509e6f7aa43-8cfdb1eae7401873352a59d044bae23e.png)

To create Products in Qonversion, go to **Entitlements → Products** and click **Create Product**.

[Entitlements – Products](https://demo.arcade.software/Evi7fa9nT4xmjzuavh4j?embed\&embed_mobile=inline\&embed_desktop=inline\&show_copy_link=true)

* **Qonversion Product ID** is your unique product identifier in Qonversion that corresponds to a unique product on the Apple App Store and Google Play Store. Qonversion SDK will use it to make purchases.

* **AppStore Product ID** – product identifier on Apple App Store. Learn more on how to create [subscriptions on iOS](https://qonversion.io/blog/configure-iap-app-store-connect/).

* **Google Play Product ID** – product identifier on Google Play Console. Learn more on how to set up [Android in-app products ](android-in-app-products).

* **Google Play Base Plan ID** - identifier of the base plan for Google Play Product. This is used for subscription products. If you're creating an in-app, leave this field empty for in-apps. In Qonversion, you will set up different products for the different base plans of the same product.

* **Associated Entitlements** - choose the entitlements that should be granted once this product is purchased.

### Offerings

Offerings are designed as a remote configuration to present particular products on specific paywalls. Moreover, you can change the products without additional app releases.

For example, you can offer one set of products on a paywall immediately after an onboarding flow is completed and another with discounts if a user has not converted later.

Here’s how it was done in RevenueCat:

To create Offerings in Qonversion, go to **Remote Config → Offerings** and click **Create Offering**.

[Create Offerings](https://demo.arcade.software/4OeIiqTaXHUzarxCOITJ?embed\&embed_mobile=inline\&embed_desktop=inline\&show_copy_link=true)

## Server-to-server notifications

To seamlessly implement server-to-server notifications, use RevenueCat S2S URLs as a temporary proxy in our system. This allows Qonversion to process new requests while still sending notifications to your existing users.

### Configure Apple App Store

1. Navigate to your Qonversion [project settings](https://dash.qonversion.io/project-settings/stores?tab=ios). Copy the server-to-server notification URL for Apple App Store.
2. Sign in to [App Store Connect](https://appstoreconnect.apple.com/apps) and select your app.
3. Navigate to the App Information section.

![](/images/docs/2058751-App_Store_Connect.png)

4. Copy the RevenueCat URL you used for server-to-server notifications and replace it with the URL from step 1.
5. Set up the RevenueCat URL as a Proxy URL in Qonversion in [project settings](https://dash.qonversion.io/project-settings/stores?tab=ios).

See more information [here](server-to-server-notifications).

### Google Developer Notifications

1. [Enable access to API here](https://console.cloud.google.com/flows/enableapi?apiid=pubsub).

   ![](/images/docs/d4fdc5f-PubSub_API.png)

2. Navigate to [project settings](https://dash.qonversion.io/project-settings/stores?tab=android), then click the "Connect to Google" button.

3. You need to copy generated **Google Developer Notifications Topic ID**.

5. Open the **Google Play Console** for your application, then navigate to **Monetization setup**.
6. In the **Real-time developer notifications** tab, insert your topic ID, click on **Save changes**, and then the **Send Test Notification** button.

It takes up to 24 hours for your [Google service credentials](service-account-key-android) to work correctly. Make sure to wait for at least 24 hours after you have created the credentials before connecting to Google Real-Time Developer Notifications.

See more information [here](google-developer-notifications).

# Install SDKs

Check out the links below for the SDK you need and follow the steps provided:

→ [iOS SDK](ios-sdk-setup) → [Android SDK](android-sdk) → [Flutter SDK](flutter-sdk) → [React Native SDK](react-native-sdk) → [Unity SDK](unity-sdk) → [Cordova Plugin](cordova) → [Capacitor Plugin](capacitor) → [Web](web-sdk) → [Kids Mode Qonversion SDKs](kids-mode-sdk)

Read more about [Installing the SDKs](install-sdk).

When you're done with the setup, it's time to get into the code!

## Launch SDK

Firstly, you need to initialize the SDK. Here's how you did it in RevenueCat:

<CodeGroup>
  ```bash bash
  func application(_ application: UIApplication,
                   didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {

      Purchases.logLevel = .debug
      Purchases.configure(withAPIKey: <public_apple_api_key>, appUserID: <app_user_id>)

  }
  ```

  ```bash bash
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    	// Override point for customization after application launch.
      
    	RCPurchases.logLevel = RCLogLevelDebug;
          [RCPurchases configureWithAPIKey:<public_apple_api_key> appUserID:<app_user_id>];
      
    	return YES;
  }
  ```

  ```bash bash
  public class App extends Application {
    @Override
    public void onCreate() {
      super.onCreate()
      Purchases.setDebugLogsEnabled(true);
      Purchases.configure(new PurchasesConfiguration.Builder(this, <public_google_api_key>).build());
    }
  }
  ```

  ```bash bash
  class App : Application() {
    override fun onCreate() {
      super.onCreate()
      Purchases.debugLogsEnabled = true
      Purchases.configure(PurchasesConfiguration.Builder(this, <public_google_api_key>).build())
    }
  }
  ```

  ```bash bash
  import 'dart:io' show Platform;

  //...

  Future<void> initPlatformState() async {
    await Purchases.setDebugLogsEnabled(true);
    
    PurchasesConfiguration configuration = PurchasesConfiguration(<public_api_key>);
    await Purchases.configure(configuration);
  }
  ```

  ```bash bash
  Purchases.setLogLevel(Purchases.LOG_LEVEL.DEBUG);
  await Purchases.configure({ apiKey: <public_api_key> });
  ```

  ```bash bash
  Purchases.PurchasesConfiguration.Builder builder = Purchases.PurchasesConfiguration.Builder.Init(<public_api_key>);
  Purchases.PurchasesConfiguration purchasesConfiguration =
      .SetAppUserId(<app_user_id>)
      .Build();
  purchases.Configure(purchasesConfiguration);
  ```

  ```bash bash
  document.addEventListener("deviceready", onDeviceReady, false);

  function onDeviceReady() {
      Purchases.setDebugLogsEnabled(true);
    	Purchases.configureWith({ apiKey: <public_api_key> });
  }
  ```

  ```bash bash
  const onDeviceReady = async () => {
      await Purchases.setLogLevel({level: LOG_LEVEL.DEBUG});
      if (Capacitor.getPlatform() === 'ios') {
          await Purchases.configure({ apiKey: <public_apple_api_key> });
      } else if (Capacitor.getPlatform() === 'android') {
          await Purchases.configure({ apiKey: <public_google_api_key> });
      }
  }
  ```
</CodeGroup>

Here's how you'll do it for Qonversion:

<CodeGroup>
  ```bash bash
  import Qonversion

  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
      let config = Qonversion.Configuration(projectKey: "projectKey", launchMode: .subscriptionManagement)
      Qonversion.initWithConfig(config)
    	return true
  }
  ```

  ```bash bash
  #import "Qonversion.h"
    
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      QONConfiguration *configuration = [[QONConfiguration alloc] initWithProjectKey:@"projectKey" launchMode:QONLaunchModeSubscriptionManagement];
      [Qonversion initWithConfig:configuration];
      
      return YES;
  }
  ```

  ```bash bash
  import com.qonversion.android.sdk.Qonversion;
  import com.qonversion.android.sdk.QonversionConfig;
  import com.qonversion.android.sdk.dto.QLaunchMode;

  public class App extends Application {
      @Override
      public void onCreate() {
          super.onCreate();
          final QonversionConfig qonversionConfig = new QonversionConfig.Builder(
                  this,
                  "projectKey",
                  QLaunchMode.SubscriptionManagement
          ).build();
          Qonversion.initialize(qonversionConfig);
      }
  }
  ```

  ```bash bash
  import com.qonversion.android.sdk.Qonversion
  import com.qonversion.android.sdk.QonversionConfig
  import com.qonversion.android.sdk.dto.QLaunchMode

  public class App : Application {
      override fun onCreate() {
          super.onCreate()
          val qonversionConfig = QonversionConfig.Builder(
              this,
              "projectKey",
              QLaunchMode.SubscriptionManagement
          ).build()
          Qonversion.initialize(qonversionConfig)
      }
  }
  ```

  ```bash bash
  import 'package:qonversion_flutter/qonversion_flutter.dart';

  final config = new QonversionConfigBuilder(
    'projectKey',
    QLaunchMode.subscriptionManagement
  ).build();
  Qonversion.initialize(config);
  ```

  ```bash bash
  import Qonversion, {
    QonversionConfigBuilder,
    LaunchMode,
  } from 'react-native-qonversion';

  const config = new QonversionConfigBuilder(
    'projectKey',
    LaunchMode.SUBSCRIPTION_MANAGEMENT
  ).build();
  Qonversion.initialize(config);
  ```

  ```bash bash
  using QonversionUnity;

  private void Start()
  {
      QonversionConfig config = new QonversionConfigBuilder(
              "projectKey",
              LaunchMode.SubscriptionManagement
          ).Build();
      Qonversion.Initialize(config);
  }
  ```

  ```bash bash
  const config = new Qonversion.ConfigBuilder(
    'projectKey',
    Qonversion.LaunchMode.SUBSCRIPTION_MANAGEMENT,
  ).build();
  Qonversion.initialize(config);
  ```

  ```bash bash
  import Qonversion, {
    QonversionConfigBuilder,
    LaunchMode,
  } from '@qonversion/capacitor-plugin';

  const config = new QonversionConfigBuilder(
    'projectKey',
    LaunchMode.SUBSCRIPTION_MANAGEMENT
  ).build();
  Qonversion.initialize(config);
  ```
</CodeGroup>

## Displaying products

In RevenueCat you did it this way:

<CodeGroup>
  ```bash bash
  Purchases.shared.getOfferings { (offerings, error) in
  		if let packages = offerings?.current?.availablePackages {
  				self.display(packages)
  		}
  }
  ```

  ```bash bash
  [[RCPurchases sharedPurchases] getOfferingsWithCompletion:^(RCOfferings *offerings, NSError *error) {
    if (offerings.current && offerings.current.availablePackages.count != 0) {
      // Display packages for sale
    } else if (error) {
      // optional error handling
    }
  }];
  ```

  ```bash bash
  Purchases.getSharedInstance().getOfferings(new ReceiveOfferingsCallback() {
    @Override
    public void onReceived(@NonNull Offerings offerings) {
      if (offerings.getCurrent() != null) {
        List<Package> availablePackages = offerings.getCurrent().getAvailablePackages();
        // Display packages for sale
      }
    }
    
    @Override
    public void onError(@NonNull PurchasesError error) {
      // An error occurred
    }
  });
  ```

  ```bash bash
  Purchases.sharedInstance.getOfferingsWith({ error ->
    // An error occurred
  }) { offerings ->
    offerings.current?.availablePackages?.takeUnless { it.isNullOrEmpty() }?.let {
      // Display packages for sale
    }
  }
  ```

  ```bash bash
  try {
    Offerings offerings = await Purchases.getOfferings();
    if (offerings.current != null && offerings.current.availablePackages.isNotEmpty) {
      // Display packages for sale
    }
  } on PlatformException catch (e) {
  	// optional error handling
  }
  ```

  ```bash bash
  try {
    const offerings = await Purchases.getOfferings();
    if (offerings.current !== null && offerings.current.availablePackages.length !== 0) {
      // Display packages for sale
    }
  } catch (e) {
   
  }
  ```

  ```bash bash
  var purchases = GetComponent<Purchases>();
  purchases.GetOfferings((offerings, error) =>
  {
    if (offerings.Current != null && offerings.Current.AvailablePackages.Count != 0){
      // Display packages for sale
    }
  });
  ```

  ```bash bash
  func displayUpsellScreen() {
    Purchases.getOfferings(
        offerings => {
          if (offerings.current !== null && offerings.current.availablePackages.length !== 0) {  
  			    // Display packages for sale
          }
        },
        error => {

        }
    );
  }
  ```

  ```bash bash
  const displayUpsellScreen = async () => {
    try {
      const offerings = await Purchases.getOfferings();
      if (offerings.current !== null && offerings.current.availablePackages.length !== 0) {  
        // Display packages for sale
      }
    } catch (error) {
      // Handle error
    }
  ```
</CodeGroup>

Here's how you'll do it for Qonversion:

<CodeGroup>
  ```bash bash
  Qonversion.shared().offerings { (offerings, error) in
    if let products = offerings?.main?.products {
      // Display products for sale
    }
  }
  ```

  ```bash bash
  [[Qonversion sharedInstance] offerings:^(QONOfferings * _Nullable offerings, NSError * _Nullable error) {
    if (offerings.main.products.count > 0) {
      // Display products for sale
    }
  }];
  ```

  ```bash bash
  Qonversion.getSharedInstance().offerings(new QonversionOfferingsCallback() {
      @Override
      public void onSuccess(@NotNull QOfferings offerings) {
          if (offerings.getMain() != null && !offerings.getMain().getProducts().isEmpty()) {
              // Display products for sale
          }
      }
      @Override
      public void onError(@NotNull QonversionError error) {
          // handle error here
      }
  });
  ```

  ```bash bash
  Qonversion.shared.offerings(object: QonversionOfferingsCallback {
      override fun onSuccess(offerings: QOfferings) {
          val mainOffering = offerings.main
          if (mainOffering != null && mainOffering.products.isNotEmpty()) {
              // Display products for sale
          }
      }
      override fun onError(error: QonversionError) {
          // handle error here
      }
  })
  ```

  ```bash bash
  try {
    final QOfferings offerings = await Qonversion.getSharedInstance().offerings();
    final List<QProduct> products = offerings.main.products;
    if (products.isNotEmpty) {
      // Display your products
    }
  } catch (e) {
    print(e);
  }
  ```

  ```bash bash
  try {
    const offerings = await Qonversion.getSharedInstance().offerings();
    if (offerings.main != null && offerings.main.products.length > 0) {
      // Display products for sale
    }
  } catch (e) {
    // handle error here
  }
  ```

  ```bash bash
  Qonversion.GetSharedInstance().Offerings((offerings, error) =>
  {
     if (error == null)
     {
              Offering mainOffering = offerings.Main;
              if(mainOffering != null)
              {
                  List<Product> products = mainOffering.Products;
                  if (products.Any())
                  {
                      // Display your products
                  }
              }
     }
     else
     {
         // Handle the error  
         Debug.Log("Error" + error.ToString());
     }
  });
  ```

  ```bash bash
  try {
    const offerings = await Qonversion.getSharedInstance().offerings();
    if (offerings.main != null && offerings.main.products.length > 0) {
      // Display products for sale
    }
  } catch (e) {
    // handle error here
  }
  ```

  ```bash bash
  try {
    const offerings = await Qonversion.getSharedInstance().offerings();
    if (offerings.main != null && offerings.main.products.length > 0) {
      // Display products for sale
    }
  } catch (e) {
    // handle error here
  }
  ```
</CodeGroup>

[See more about Offerings](offerings)

## Making purchases

RevenueCat:

<CodeGroup>
  ```bash bash
  Purchases.shared.purchase(package: package) { (transaction, customerInfo, error, userCancelled) in
    if customerInfo.entitlements["your_entitlement_id"]?.isActive == true {
      // Unlock that great "pro" content              
    }
  }
  ```

  ```bash bash
  [[RCPurchases sharedPurchases] purchasePackage:package withCompletion:^(RCStoreTransaction *transaction, RCCustomerInfo *customerInfo, NSError *error, BOOL cancelled) {
    if (customerInfo.entitlements[@"your_entitlement_id"].isActive) {
      // Unlock that great "pro" content
    }
  }];
  ```

  ```bash bash
  Purchases.getSharedInstance().purchase(
  	new PurchaseParams.Builder(this, aPackage).build(), 
  	new PurchaseCallback() {
      @Override
      public void onCompleted(@NonNull StoreTransaction storeTransaction, @NonNull CustomerInfo customerInfo) {
  			if (customerInfo.getEntitlements().get(<my_entitlement_identifier>).isActive()) {
  				// Unlock that great "pro" content
  			}
  		}

  		@Override
  		public void onError(@NonNull PurchasesError purchasesError, boolean b) {
  			// No purchase
  		}
  	}
  );
  ```

  ```bash bash
  Purchases.sharedInstance.purchaseWith(
    PurchaseParams.Builder(this, aPackage).build(),
    onError = { error, userCancelled -> /* No purchase */ },
    onSuccess = { storeTransaction, customerInfo ->
      if (customerInfo.entitlements["my_entitlement_identifier"]?.isActive == true) {
        // Unlock that great "pro" content
      }
    }
  )
  ```

  ```bash bash
  try {
    CustomerInfo customerInfo = await Purchases.purchasePackage(package);
    if (customerInfo.entitlements.all["my_entitlement_identifier"].isActive) {
      // Unlock that great "pro" content
    }
  } on PlatformException catch (e) {
    var errorCode = PurchasesErrorHelper.getErrorCode(e);
    if (errorCode != PurchasesErrorCode.purchaseCancelledError) {
      showError(e);  	          
    }
  }
  ```

  ```bash bash
  try {
    const { customerInfo } = await Purchases.purchasePackage(package);
    if (
      typeof customerInfo.entitlements.active["my_entitlement_identifier"] !==
      "undefined"
    ) {
      // Unlock that great "pro" content
    }
  } catch (e) {
    if (!e.userCancelled) {
      showError(e);
    }
  }
  ```

  ```bash bash
  Purchases purchases = GetComponent<Purchases>();
  purchases.PurchasePackage(package, (productIdentifier, customerInfo, userCancelled, error) =>
  {
    if (customerInfo.Entitlements.Active.ContainsKey("my_entitlement_identifier")) {
      // Unlock that great "pro" content
    }
  });
  ```

  ```bash bash
  Purchases.purchasePackage(package, ({ productIdentifier, customerInfo }) => {
      if (typeof customerInfo.entitlements.active.my_entitlement_identifier !== "undefined") {
        // Unlock that great "pro" content
      }
    },
    ({error, userCancelled}) => {
      // Error making purchase
    }
  );
  ```

  ```bash bash
  try {
    const purchaseResult = await Purchases.purchasePackage({ aPackage: packageToBuy });
    if (typeof purchaseResult.customerInfo.entitlements.active['my_entitlement_identifier'] !== "undefined") {
      // Unlock that great "pro" content
    }
  } catch (error: any) {
    if (error.code === PURCHASES_ERROR_CODE.PURCHASE_CANCELLED_ERROR) {
      // Purchase cancelled
    } else {
      // Error making purchase
    }
  }
  ```
</CodeGroup>

Qonversion:

<CodeGroup>
  ```bash bash
  Qonversion.shared().purchase(product) { (result) in
    if result.isSuccessful {
      if let premium: Qonversion.Entitlement = result.entitlements["premium"], premium.isActive {
        // Grant user access to premium features
      }
    } else if result.isCanceledByUser {
      // Handle canceled purchase
    } else if result.isPending {
      // Handle pending purchase
    } else {
      // Handle errors
    }
  }
  ```

  ```bash bash
  [[Qonversion sharedInstance] purchaseWithResult:product completion:^(QONPurchaseResult * _Nonnull result) {
    if (result.isSuccessful) {
      QONEntitlement *premiumEntitlement = result.entitlements[@"premium"];
      if (premiumEntitlement && premiumEntitlement.isActive) {
        // Grant user access to premium features
      }
    } else if (result.isCanceledByUser) {
      // Handle canceled purchase
    } else if (result.isPending) {
      // Handle pending purchase
    } else {
      // Handle errors
    }
  }];
  ```

  ```bash bash
  Qonversion.getSharedInstance().purchase(this, product, new QonversionPurchaseCallback() {
      @Override
      public void onResult(@NonNull QPurchaseResult result) {
          if (result.isSuccessful()) {
              QEntitlement premium = result.getEntitlements().get("premium");
              if (premium != null && premium.isActive()) {
                  // Grant user access to premium features
              }
          } else if (result.isCanceledByUser()) {
              // Handle canceled purchase
          } else if (result.isPending()) {
              // Handle pending purchase
          } else {
              // Handle errors
          }
      }
  });
  ```

  ```bash bash
  Qonversion.shared.purchase(this, product, object : QonversionPurchaseCallback {
      override fun onResult(result: QPurchaseResult) {
          when {
              result.isSuccessful -> {
                  val premium = result.entitlements["premium"]
                  if (premium != null && premium.isActive) {
                      // Grant user access to premium features
                  }
              }
              result.isCanceledByUser -> {
                  // Handle canceled purchase
              }
              result.isPending -> {
                  // Handle pending purchase
              }
              else -> {
                  // Handle errors
              }
          }
      }
  })
  ```

  ```bash bash
  final result = await Qonversion.getSharedInstance().purchaseWithResult(product);

  if (result.isSuccess) {
    final premium = result.entitlements?['premium'];
    if (premium != null && premium.isActive) {
      // Grant user access to premium features
    }
  } else if (result.isCanceled) {
    // Handle canceled purchase
  } else if (result.isPending) {
    // Handle pending purchase
  } else {
    // Handle errors
  }
  ```

  ```bash bash
  const result: PurchaseResult = await Qonversion.getSharedInstance().purchaseWithResult(product);

  if (result.isSuccess) {
    const premium = result.entitlements?.get('premium');
    if (premium && premium.isActive) {
      // Grant user access to premium features
    }
  } else if (result.isCanceled) {
    // Handle canceled purchase
  } else if (result.isPending) {
    // Handle pending purchase
  } else {
    // Handle errors
  }
  ```

  ```bash bash
  Qonversion.GetSharedInstance().Purchase(product, (result) =>
  {
      if (result.IsSuccess)
      {
          if (result.Entitlements != null && 
              result.Entitlements.TryGetValue("premium", out var premium) && 
              premium.IsActive)
          {
              // Grant user access to premium features
          }
      }
      else if (result.IsCanceled)
      {
          // Handle canceled purchase
      }
      else if (result.IsPending)
      {
          // Handle pending purchase
      }
      else
      {
          // Handle errors
      }
  });
  ```

  ```bash bash
  const result = await Qonversion.getSharedInstance().purchase(product);

  if (result.isSuccess) {
    const premium = result.entitlements?.get('premium');
    if (premium && premium.isActive) {
      // Grant user access to premium features
    }
  } else if (result.isCanceled) {
    // Handle canceled purchase
  } else if (result.isPending) {
    // Handle pending purchase
  } else {
    // Handle errors
  }
  ```

  ```bash bash
  const result = await Qonversion.getSharedInstance().purchase(product);

  if (result.isSuccess) {
    const premium = result.entitlements?.get('premium');
    if (premium && premium.isActive) {
      // Grant user access to premium features
    }
  } else if (result.isCanceled) {
    // Handle canceled purchase
  } else if (result.isPending) {
    // Handle pending purchase
  } else {
    // Handle errors
  }
  ```
</CodeGroup>

## Restore purchases

If your app has a restore purchases feature on paywalls, just use the Qonversion `restore()` function when users want to restore their purchases.

<CodeGroup>
  ```bash bash
  Qonversion.shared().restore { [weak self] (entitlements, error) in
    if let error = error {
      // Handle error
    }
    
    if let entitlement: Qonversion.Entitlement = entitlements["plus"], entitlement.isActive {
      // Restored and entitlement is active 
    }
  ```

  ```bash bash
  [[Qonversion sharedInstance] restore:^(NSDictionary<NSString *, QONEntitlement *> * _Nonnull result, NSError * _Nullable error) {
    if (error) {
      // Handle error
    }
    QONEntitlement *entitlement = result[@"active"];
    if (entitlement && entitlement.isActive) {
      // Restored and entitlement is active
    }
  }];
  ```

  ```bash bash
  Qonversion.getSharedInstance().restore(new QonversionEntitlementsCallback() {
      @Override
      public void onSuccess(@NotNull Map<String, QEntitlement> entitlements) {
          QEntitlement premiumEntitlement = entitlements.get("premium");

          if (premiumEntitlement != null && premiumEntitlement.isActive()) {
              // handle active entitlement here
          }
      }

      @Override
      public void onError(@NotNull QonversionError error) {
          // handle error here
      }
  });
  ```

  ```bash bash
  Qonversion.shared.restore(object : QonversionEntitlementsCallback {
      override fun onSuccess(entitlements: Map<String, QEntitlement>) {
          val premiumEntitlement = entitlements["premium"]
          if (premiumEntitlement != null && premiumEntitlement.isActive) {
              // handle active entitlement here
          }
      }

      override fun onError(error: QonversionError) {
          // handle error here
      }
  })
  ```

  ```bash bash
  try {
    final Map<String, QEntitlement> entitlements = await Qonversion.getSharedInstance().restore();
  } catch (e) {
    print(e);
  }
  ```

  ```bash bash
  try {
    const entitlements: Map<string, Entitlement> = await Qonversion.getSharedInstance().restore();
   } catch (e) {
    console.log(e);
  }
  ```

  ```bash bash
  Qonversion.GetSharedInstance().Restore((entitlements, error) =>
  {
        if (error == null)
        {
           // Handle entitlements here
        }
        else
        {
          // Handle the error  
          Debug.Log("Error" + error.ToString());
        }
  });
  ```

  ```bash bash
  try {
      const entitlements = await Qonversion.getSharedInstance().restore();
  } catch (e) {
      console.log(e);
  }
  ```

  ```bash bash
  try {
    const entitlements: Map<string, Entitlement> = await Qonversion.getSharedInstance().restore();
   } catch (e) {
    console.log(e);
  }
  ```
</CodeGroup>

## User status

To check the customer status in Qonversion, you need to use Entitlements. In RevenueCat, you used Customer info and entitlements.

RevenueCat:

<CodeGroup>
  ```bash bash
  Purchases.shared.getCustomerInfo { (customerInfo, error) in
      // access latest customerInfo
  		if customerInfo.entitlements[<your_entitlement_id>]?.isActive == true {
    			// user has access to "your_entitlement_id"                
      }
  }
  ```

  ```bash bash
  [[RCPurchases sharedPurchases] customerInfoWithCompletion:^(RCCustomerInfo * customerInfo, NSError * error) {
      // access latest customerInfo
    	if (customerInfo.entitlements[@<your_entitlement_id>].isActive) {
   				// user has access to "your_entitlement_id"
  		}
  }];
  ```

  ```bash bash
  Purchases.sharedInstance.getCustomerInfo({ error -> /* Optional error handling */ }) { customerInfo ->
  	  // access latest customerInfo
  	  if (customerInfo.entitlements[<your_entitlement_id>]?.isActive == true) {
  				// user has access to "your_entitlement_id"                
  		}
  }
  ```

  ```bash bash
  Purchases.getSharedInstance().getCustomerInfo(new ReceiveCustomerInfoCallback() {
  	  @Override
    	public void onReceived(@NonNull CustomerInfo customerInfo) {
      		// access latest customerInfo
  		    if (customerInfo.getEntitlements().get(<your_entitlement_id>).isActive()) {
  						// user has access to "your_entitlement_id"
  				}
  	  }
    
      @Override
      public void onError(@NonNull PurchasesError error) {

      }
  });
  ```

  ```bash bash
  try {
    CustomerInfo customerInfo = await Purchases.getCustomerInfo();
    // access latest customerInfo
    if (customerInfo.entitlements.all[<my_entitlement_identifier>].isActive) {
      // Grant user "pro" access
    }
  } on PlatformException catch (e) {
    // Error fetching customer info
  }
  ```

  ```bash bash
  try {
    const customerInfo = await Purchases.getCustomerInfo();
    // access latest customerInfo
    if(typeof customerInfo.entitlements.active[<my_entitlement_identifier>] !== "undefined") {
  	  // Grant user "pro" access
  	}
  } catch (e) {
   // Error fetching customer info
  }
  ```

  ```bash bash
  var purchases = GetComponent<Purchases>();
  purchases.GetCustomerInfo((customerInfo, error) =>
  {
    // access latest customerInfo
    if (customerInfo.Entitlements.Active.ContainsKey(<my_entitlement_identifier>)) {
    	// Unlock that great "pro" content
  	}
  });
  ```

  ```bash bash
  Purchases.getCustomerInfo(
    customerInfo => {
      // access latest customerInfo
      if(typeof customerInfo.entitlements.active[<my_entitlement_identifier>] !== "undefined") {
  			  // Grant user "pro" access
  		}
    },
    error => {
      // Error fetching customer info
    }
  );
  ```

  ```bash bash
  await Purchases.addCustomerInfoUpdateListener((customerInfo) => {
    if(typeof customerInfo.entitlements.active[<my_entitlement_identifier>] !== "undefined") {
      // Grant user "pro" access
    }
  });
  ```
</CodeGroup>

Qonversion:

<CodeGroup>
  ```bash bash
  Qonversion.shared().checkEntitlements { (entitlements, error) in
    if let error = error {
      // handle error
      return
    }
    
    if let premium: Qonversion.Entitlement = entitlements["premium"], premium.isActive {
      // unlock feature
    }
  }
  ```

  ```bash bash
  [[Qonversion sharedInstance] checkEntitlements:^(NSDictionary<NSString *, QONEntitlement *> * _Nonnull entitlements,
                                  NSError * _Nullable error) {
      QONEntitlement *premiumEntitlement = entitlements[@"premium"];
      if (premiumEntitlement && premiumEntitlement.isActive) {
        // unlock feature
      }
  }];
  ```

  ```bash bash
  Qonversion.getSharedInstance().checkEntitlements(new QonversionEntitlementsCallback() {
      @Override
      public void onSuccess(@NotNull Map<String, QEntitlement> entitlements) {
          final QEntitlement premiumEntitlement = entitlements.get("premium");

          if (premiumEntitlement != null && premiumEntitlement.isActive()) {
              // unlock feature
          }
      }

      @Override
      public void onError(@NotNull QonversionError error) {
          // handle error here
      }
  });
  ```

  ```bash bash
  Qonversion.shared.checkEntitlements(object: QonversionEntitlementsCallback {
      override fun onSuccess(entitlements: Map<String, QEntitlement>) {
          val premiumEntitlement = entitlements["premium"]
          if (premiumEntitlement != null && premiumEntitlement.isActive) {
              // unlock feature
          }
      }

      override fun onError(error: QonversionError) {
          // handle error here
      }
  })
  ```

  ```bash bash
  try {
    final Map<String, QEntitlement> entitlements = await Qonversion.getSharedInstance().checkEntitlements();
    final premium = entitlements['premium'];
    if (premium != null && premium.isActive) {
      // unlock feature
    }
  } catch (e) {
    print(e);
  }
  ```

  ```bash bash
  try {
    const entitlements = await Qonversion.getSharedInstance().checkEntitlements();

    const premiumEntitlement = entitlements.get('premium');
    if (premiumEntitlement != null) {
      // unlock feature
    }
  } catch (e) {
    // handle error here
  }
  ```

  ```bash bash
  Qonversion.GetSharedInstance().CheckEntitlements((entitlements, error) =>
  {
      if (error == null)
      {
          if (entitlements.TryGetValue("premium", out Entitlement premium) && premium.IsActive)
          {
              // unlock feature
          }
      }
      else
      {
          // Handle the error  
          Debug.Log("Error" + error.ToString());
      }
  });
  ```

  ```bash bash
  try {
      const entitlements = await Qonversion.getSharedInstance().checkEntitlements();

      const premiumEntitlement = entitlements.get('premium');
      if (premiumEntitlement != null) {
          // unlock feature
      }
  } catch (e) {
      // handle error here
  }
  ```

  ```bash bash
  try {
    const entitlements = await Qonversion.getSharedInstance().checkEntitlements();

    const premiumEntitlement = entitlements.get('premium');
    if (premiumEntitlement != null) {
      // unlock feature
    }
  } catch (e) {
    // handle error here
  }
  ```
</CodeGroup>

## Authorization system

<Info>
  ### Cross-device and cross-platform access

  Set up this section only if you need cross-device and cross-platform access and your project includes an authorization system.
</Info>

Qonversion lets you identify your signed-in users and unlock premium access across multiple devices. Use the `identify()` method to link a user to your signed-in subscriber. Call this method every time you want to use User Identity. For example, when a user logs in. User Identity provides a convenient way of managing premium access of your existing subscribers, including the following cases:

* A user reinstalls your app for any reason. Using the same User ID allows you to provide premium access linked to previously purchased products.
* A user logs in on several devices. You can provide premium access based on a subscription purchased on one of his devices.
* A user logs in on iOS and Android versions of your app. You can provide premium access based on a subscription purchased on one of the platforms.

### Logging in

When a user logs into his account, call `identify()`.

<CodeGroup>
  ```bash bash
  Qonversion.shared().identify("your_custom_user_id")

  // or the following option, if you want to get notified about the result.

  Qonversion.shared().identify("your_custom_user_id") { user, error in
    // use user if necessary
  }
  ```

  ```bash bash
  [[Qonversion sharedInstance] identify:@"your_custom_user_id"];

  // or the following option, if you want to get notified about the result.

  [[Qonversion sharedInstance] identify:@"your_custom_user_id" completion:^(QONUser * _Nullable user, NSError * _Nullable error) {
    // use user if necessary
  }];
  ```

  ```bash bash
  Qonversion.getSharedInstance().identify("your_custom_user_id");

  // or the following option, if you want to get notified about the result.

  Qonversion.getSharedInstance().identify("your_custom_user_id", new QonversionUserCallback() {
      @Override
      public void onSuccess(@NonNull QUser user) {
          // use user if necessary
      }

      @Override
      public void onError(@NonNull QonversionError error) {
          // handle error here
      }
  });
  ```

  ```bash bash
  Qonversion.shared.identify("your_custom_user_id")

  // or the following option, if you want to get notified about the result.

  Qonversion.shared.identify("your_custom_user_id", object : QonversionUserCallback {
      override fun onSuccess(user: QUser) {
          // use user if necessary
      }

      override fun onError(error: QonversionError) {
          // handle error here
      }
  })
  ```

  ```bash bash
  try {
    final userInfo = await Qonversion.getSharedInstance().identify("your_custom_user_id");
    // use userInfo if necessary
  } catch (e) {
    // handle error here
  }
  ```

  ```bash bash
  try {
    const userInfo = await Qonversion.getSharedInstance().identify('your_custom_user_id');
    // use userInfo if necessary
  } catch (e) {
    // handle error here
  }
  ```

  ```bash bash
  Qonversion.GetSharedInstance().Identify("your_custom_user_id")

  // or the following option, if you want to get notified about the result.

  Qonversion.GetSharedInstance().Identify("your_custom_user_id", (userInfo, error) =>
  {
      if (error == null)
      {
          // use userInfo if necessary
      }
      else
      {
          // Handle the error  
          Debug.Log("Error" + error.ToString());
      }
  });
  ```

  ```bash bash
  try {
    const userInfo = await Qonversion.getSharedInstance().identify('your_custom_user_id');
    // use userInfo if necessary
  } catch (e) {
    // handle error here
  }
  ```

  ```bash bash
  try {
    const userInfo = await Qonversion.getSharedInstance().identify('your_custom_user_id');
    // use userInfo if necessary
  } catch (e) {
    // handle error here
  }
  ```

  ```bash bash
  curl --location --request POST 'https://api.qonversion.io/v3/identities/new_identities_user' \
  --header 'Authorization: Bearer ' \
  --header 'Content-Type: application/json' \
  --data-raw '{
      "user_id": "QON_38a2d811afd54a433587620f8696266e"
  }'

  {
      "id": "new_identities_user",
      "user_id": "QON_38a2d811afd54a433587620f8696266e"
  }
  ```
</CodeGroup>

<Warning>
  ### Use the unique user ID stored in your database

  Always use unique user ID values. Otherwise, a user can get matched to another user's entitlements status.
</Warning>

To check entitlements for identified users, you can call the `checkEntitlements` function, which we discussed above.

### Logging out

You need to call the `logout()` method to handle entitlements for an unauthorized user. Call this method when a user logs out within your app:

<CodeGroup>
  ```bash bash
  Qonversion.shared().logout()
  ```

  ```bash bash
  [[Qonversion sharedInstance] logout];
  ```

  ```bash bash
  Qonversion.getSharedInstance().logout();
  ```

  ```bash bash
  Qonversion.shared.logout()
  ```

  ```bash bash
  Qonversion.getSharedInstance().logout();
  ```

  ```bash bash
  Qonversion.getSharedInstance().logout();
  ```

  ```bash bash
  Qonversion.GetSharedInstance().Logout();
  ```

  ```bash bash
  Qonversion.getSharedInstance().logout();
  ```

  ```bash bash
  Qonversion.getSharedInstance().logout();
  ```
</CodeGroup>

When a user logs back into his account, don't forget to use `identify()` method again.

# User-base migration

Those steps have to be done to keep the system working smoothly for your current user base. The necessity of steps depends on the complexity of your system. The simplest system is represented by a single platform infrastructure (Apple, Google, or Stripe). The complex one includes a few platforms with authorization system, your backend infrastructure, and WebHooks handler.

## Client-side migration

Follow these steps to sync user status and retrieve the latest data from Google and Apple on your current device. Сall the `syncHistoricalData()` method right after Qonversion SDK initialization to synchronize all the device-related data and ensure that none of the entitlements has been missed.

<Warning>
  ### Qonversion Android SDK 9.+ limitation

  For Qonversion Android SDK 9.+, the method `syncHistoricalData()` has been removed because of a limitation in Google Play Billing Library 8, which prevents the retrieval of historical purchases
</Warning>

## User-database migration

Once you have the app version with Qonversion SDK up and running, it's time to proceed to the server-side migration.

1. Prepare files with [AppStore with Base64 encoded receipt data](migrating-subscriptions#app-store-data-migration-file) or [Google Play with purchase tokens](migrating-subscriptions#google-play-data-migration-file). If you do not have receipt data or purchase tokens on your side but are already running your subscription management with a third-party vendor, you should ask the vendor’s support team for the required data file.
2. Then simply **share the files with us** using our support chat and provide CSV files.

# Release

Once you're done with these steps go ahead and release your app. For complex systems with cross-platform access and authorization setups, make sure you're in touch with us and our team has verified your user database migration.

<Check>
  ### You're good to go

  Check out the detailed RevenueCat and Qonversion [feature comparison](https://qonversion.io/revenuecat-alternative) and don't hesitate to contact us if you have questions.
</Check>

***

[Migrating In-App Subscriptions](migrating-subscriptions)

[Migrating from Adapty to Qonversion](adapty-migration-guide)
